# Memory Dependence Prediction

## 1. 背景与问题

在现代乱序处理器中，准确预测内存依赖关系是提高性能的关键因素。当处理器允许 load 指令绕过先前的 store 指令执行时，必须确保这些 load 不会访问到尚未提交的 store 所修改的内存位置。不正确的内存依赖预测会导致：

- **过度保守**：不必要地延迟独立的 load 指令
- **过度激进**：需要频繁地重新执行 load 和其依赖指令

传统上，处理器使用以下几种方法处理内存依赖：

- **无投机执行**：所有 load 等待所有先前的 store 完成
- **地址匹配**：使用 store queue 检查地址重叠
- **简单预测**：使用历史行为预测 load-store 依赖关系

## 2. Store Sets

论文 [[ISCA'98] Memory Dependence Prediction using Store Sets](https://acg.cis.upenn.edu/milom/cis501-Fall10/papers/store-sets.pdf)

### 2.1. 核心思想

Store Sets 算法基于一个关键观察：**特定的 load 和 store 指令对会反复产生依赖冲突**。该算法通过以下方式工作：

1. 对每个 load 指令，维护一个"store set"——所有曾经与该 load 产生依赖冲突的 store 指令集合
2. 当 load 和 store 执行顺序错误导致冲突时，将该 store 添加到 load 的 store set 中
3. 在后续执行中，如果检测到 load 和其 store set 中的指令，处理器会强制 load 等待这些 store 完成

这种方法比简单的启发式方法更精确，因为它能够学习并记住特定的 load-store 依赖对。

### 2.2 常见依赖模式

- 多个 load 操作依赖于单个 store 操作（常见情况：一个写入者，多个读取者）
- 一个 load 操作依赖于多个 store 操作：
  - **情况 1**: 分支，一个 load 可能依赖于不同分支路径上的 store
  - **情况 2**: 字大小的结构体被分割成多个字段，多个字段被写入但整个结构体被一次性读取
  - **情况 3**: WAW (Write-After-Write) 情况

### 2.3. 硬件实现

Store Sets 算法需要两个主要的硬件表：
![](docs/CPU/Backend/LSU/MDP/attachments/Pasted%20image%2020250504000801.png)
#### 2.3.1 Store Set ID Table (SSIT)

- **功能**：将指令的 PC 映射到其 Store Set ID (SSID)
- **结构**：4K 条目的直接映射表，每个条目包含一个有效位和 SSID
- **索引方式**：使用指令 PC 的低位进行索引
- **访问时机**：在指令取指阶段被访问

#### 2.3.2 Last Fetched Store Table (LFST)

- **功能**：跟踪每个 store set 中最近取指的 store 指令
- **结构**：128 条目表，每个条目包含指令编号(inum)和有效位
- **索引方式**：使用 SSID 索引
- **访问时机**：指令取指和调度阶段

#### 2.3.3 操作流程

- **初始化**: 程序开始时，SSIT 中的所有条目都无效。初始情况下，store 和 load 指令访问表格时不会获得有效的内存依赖信息。

- **违例处理**: 当 load 提交内存顺序违例时，SSIT 中会创建一个 store set。冲突中涉及的 load 和 store 指令被分配一个 store set 标识符（SSID X）。SSID 可以通过多种方式分配，例如对 load 的 PC 进行异或哈希。SSID X 会被写入 SSIT 中的两个位置：一个由 load PC 索引，另一个由 store PC 索引。

- **Store 处理**: 当该 store PC 再次被取指时，它会读取由其 PC 索引的 SSIT 条目。由于 SSID 有效，它使用该 store set 的 SSID 访问 LFST。如果它没有找到来自 store set X 的有效最近取指指令，它不会依赖于另一个 store。该 store 会将自己的指令序号（inum）写入 LFST。

- **Load 处理**: 当 load 指令随后被取指时，它使用 SSID X 访问 SSIT 然后是 LFST。LFST 通知指令调度器该 load 依赖于其中找到的 store 指令。调度器然后在 load 和 store 之间强制执行依赖关系，类似于它处理寄存器依赖约束的方式。

- **多重冲突**: 如果 load 后来与另一个 store 发生冲突，SSIT 会因新的内存顺序违例而更新。SSID X 被复制到由新 store 的 PC 索引的 SSIT 条目中。现在 SSIT 中有三个条目指向 SSID X。下次取指这些指令时，第二个 store 将依赖于第一个 store，load 将依赖于第二个 store。

### 2.4. Store Set 合并策略

由于一个 store 只能属于一个 store set，当一个 store 需要属于多个 store set 时，需要合并策略：

1. 如果两者都没有 store set，创建新的并分配给两者
2. 如果只有一个有 store set，另一个继承这个 store set
3. 如果两者都有不同的 store set，选择一个作为"赢家"（例如编号较小的）

这种合并策略能避免 store set 表中的抖动，同时引入的假依赖关系影响很小。

### 2.5. 性能评估

论文中的实验结果表明：

- **Spec95 基准测试**：Store Sets 算法实现了接近理想内存依赖预测的 97% 性能
- **硬件开销**：仅需 4KB SSIT (4K 条目)和 512 字节 LFST (128 条目)
- **改进**：比最好的替代方案（同步预测）提高了 15% 的性能

重要的是，Store Sets 算法在复杂的依赖模式下表现出色，包括：

- 一个 load 依赖多个 store 的情况（如结构体访问）
- 多个 load 依赖同一个 store 的情况（一写多读）
- 控制流依赖模式（如分支内的依赖）

### 2.5. Store Sets 算法中的关键权衡

Store Sets 算法的设计中包含多项精心考虑的权衡决策，这些决策直接影响了算法的实际效果。

#### 2.6.1 Store 指令只能属于单一 Store Set 的权衡

Store Sets 设计中的一个关键限制是：**一个 store 指令只能属于一个 store set**。

**为什么采用这种限制：**

- **硬件复杂度降低**：允许 store 属于多个 store set 会显著增加硬件复杂度，需要多对多映射表
- **查找速度优化**：在关键的指令取指阶段，单一映射允许 O(1) 时间复杂度的依赖查找
- **LFST 结构简化**：每个 SSID 只需跟踪一个最近 store，而不是多个 store 的列表
- **存储空间优化**：每个 PC 只需一个 SSID 映射条目，节省芯片面积

**这种限制的代价：**

- **引入假依赖**：当一个 store 本应属于多个独立 store set 时，合并策略会强制这些集合中的所有 load 和 store 产生序列化依赖
- **潜在性能下降**：这些假依赖可能导致原本可并行执行的指令被不必要地序列化

论文通过实验表明，尽管存在这些假依赖，但在大多数程序中性能影响微乎其微（少于 1%），而硬件简化带来的优势更为显著。

#### 2.6.2 表大小与覆盖率的权衡

SSIT 和 LFST 的大小选择反映了面积与性能的权衡：

**较小表的优势：**

- 减少芯片面积占用和功耗消耗
- 访问延迟更短，对关键时序路径影响更小

**较小表的劣势：**

- **哈希冲突增多**：直接映射表容易产生冲突，导致有效预测信息被替换
- **覆盖率降低**：无法跟踪所有可能的依赖关系

论文通过实验确定：

- 4K 大小的 SSIT 和 128 条目的 LFST 提供了最佳的性能/面积比
- 更大的表（如 16K SSIT）仅带来约 1-2% 的额外性能提升，但面积成本显著增加

#### 2.6.3 预测精度与冲突解决的权衡

当内存依赖预测失败时，处理器需要恢复执行顺序：

**保守预测（预测更多依赖）：**

- **优势**：减少恢复/重新执行的次数，提高系统稳定性
- **劣势**：引入不必要的指令序列化，限制指令级并行度

**激进预测（预测更少依赖）：**

- **优势**：最大化指令级并行度，提高处理器吞吐量
- **劣势**：当预测错误时付出更高的恢复成本

Store Sets 算法通过学习实际执行中的依赖关系，在这两种极端之间找到了平衡点。论文观察到，针对不同的工作负载，这种权衡可能需要动态调整，某些程序对依赖预测错误非常敏感，而其他程序则能容忍较高的错误率。

#### 2.6.4 清除机制的效率与准确性权衡

Store Set 中关于清除机制的选择也体现了重要权衡：

**周期性全局清除：**

- **优势**：实现简单，硬件开销小
- **劣势**：可能过早清除有用信息，或者清除不及时导致过时信息积累

**基于计数器的选择性清除：**

- **优势**：更精确地保留有用信息，丢弃过时信息
- **劣势**：额外的硬件复杂度（需要为每个 SSIT 条目添加计数器）

实验表明，简单的周期性清除在大多数情况下表现良好，而更复杂的计数器方法只在少数场景下显示出明显优势。这再次体现了 Store Sets 设计追求"足够好"而非"完美"的实用哲学。

### 2.8. 结论

Store Sets 算法通过学习特定 load 和 store 指令之间的依赖关系，显著提高了乱序处理器的性能。它的关键创新在于：

1. 将相关的 store 指令分组到"store sets"中
2. 维护最小且高效的硬件结构（SSIT 和 LFST）
3. 采用有效的合并策略避免表抖动

这种设计在实际处理器架构中证明是高效且实用的，为后续内存依赖预测技术奠定了坚实基础。Store Sets 算法平衡了预测精度与硬件成本，实现了接近理想预测器的性能，同时保持了实现的简洁性。

Store Sets 被认为是内存依赖预测的经典算法，后续研究包括：

- **NoSQ 架构**：去除传统 store queue，仅使用预测器和 re-execution
- **DMDP (2018)**：通过在寄存器重命名阶段插入指令改变 load 行为，减少 NoSQ 架构中的重执行
- **编译器辅助方法**：使用静态分析识别无依赖的 load 指令

## 参考文献

- [乱序执行简介（第二部分）](https://jia.je/hardware/2022/03/31/brief-into-ooo-2/#memory-dependence-predictor)
- [使用 Store Sets 进行内存依赖预测 (Chrysos & Emer, 1998)](https://acg.cis.upenn.edu/milom/cis501-Fall10/papers/store-sets.pdf)
- [使用静态分析改进内存依赖预测 (Panayi et al., 2024)](https://arxiv.org/abs/2403.08056)
- [Dynamic Memory Dependence Predication (Jin & Önder, 2018)](https://ieeexplore.ieee.org/document/8416831)
